// ==UserScript==
// @name         üß† Auto Sora
// @namespace    http://tampermonkey.net/
// @version      4.8
// @description  Auto generate prompt list, bulk download (PNG, multithreaded), single file download, auto crop (16:9, 9:16, 1:1), H/V/Square filter, Stop button, Find Similar Image (background tab), Glass UI
// @author       Matthew M.
// @match        *://sora.com/*
// @match        *://www.sora.com/*
// @updateURL    https://raw.githubusercontent.com/matthewm1805/tampermonkey/main/%F0%9F%A7%A0%20Auto%20Sora.user.js
// @downloadURL  https://raw.githubusercontent.com/matthewm1805/tampermonkey/main/%F0%9F%A7%A0%20Auto%20Sora.user.js
// @grant        none
// @require      https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js
// ==/UserScript==

(function () {
    'use strict';

    // --- Global Variables ---
    let promptQueue = [];
    let totalPromptCount = 0;
    let isRunning = false;
    let countdownInterval = null;
    let cooldownTime = 130;
    let selectedImageUrls = new Set();
    let isDownloading = false;
    let downloadErrors = 0;
    let isFindSimilarModeActive = false;

    function log(msg) { console.log(`[Auto Sora v4.8] ${msg}`); }
    function getTimestamp() { const now = new Date(); const pad = n => String(n).padStart(2, '0'); return `${pad(now.getDate())}${pad(now.getMonth() + 1)}${String(now.getFullYear()).slice(2)}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`; }
    function triggerDownload(blob, filename) { const link = document.createElement("a"); link.href = URL.createObjectURL(blob); link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href); log(`Triggered download for ${filename}`); }

    function updateImageSelection() { log("Updating image selections based on H/V/Square filters..."); try { const filterHorizState = document.getElementById('sora-select-horizontal')?.checked ?? false; const filterVertState = document.getElementById('sora-select-vertical')?.checked ?? false; const filterSquareState = document.getElementById('sora-select-square')?.checked ?? false; selectedImageUrls.clear(); document.querySelectorAll(".sora-image-wrapper").forEach(wrapper => { const checkbox = wrapper.querySelector(".sora-image-checkbox"); const img = wrapper.querySelector("img"); if (!checkbox || !img) return; const imgWidth = (img.complete && img.naturalWidth > 0) ? img.naturalWidth : img.width; const imgHeight = (img.complete && img.naturalHeight > 0) ? img.naturalHeight : img.height; let checkThisBox = false; if (img.complete && imgWidth > 0 && imgHeight > 0) { const isHoriz = imgWidth > imgHeight; const isVert = imgHeight > imgWidth; const isSquare = imgWidth === imgHeight; if (!filterHorizState && !filterVertState && !filterSquareState) { checkThisBox = false; } else { checkThisBox = (filterHorizState && isHoriz) || (filterVertState && isVert) || (filterSquareState && isSquare); } checkbox.checked = checkThisBox; if (checkThisBox) { selectedImageUrls.add(img.src); } } else if (!img.complete) { checkThisBox = checkbox.checked; if (checkThisBox) { selectedImageUrls.add(img.src); } } else { checkbox.checked = false; if (selectedImageUrls.has(img.src)) { selectedImageUrls.delete(img.src); } log(`Image ${img.src.substring(0,30)}... has invalid dimensions (${imgWidth}x${imgHeight}) after loading.`); } }); updateSelectedCount(); log(`Selection updated. ${selectedImageUrls.size} images selected based on filters.`); } catch (e) { log("Error during image selection update:"); console.error(e); } }

    function createUI() {
        const wrapper = document.createElement('div'); wrapper.id = 'sora-auto-ui';
        wrapper.style.cssText = `position: fixed; bottom: 15px; left: 20px; background: rgba(35, 35, 40, 0.65); backdrop-filter: blur(10px) saturate(180%); -webkit-backdrop-filter: blur(10px) saturate(180%); padding: 20px 20px 15px 20px; border-radius: 16px; z-index: 999999; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37); width: 330px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; border: 1px solid rgba(255, 255, 255, 0.12); color: #e0e0e0; transition: opacity 0.3s ease, transform 0.3s ease; opacity: 1; transform: scale(1); display: block;`;
        wrapper.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;"> <h3 style="margin: 0; font-size: 17px; display: flex; align-items: center; gap: 10px; color: #ffffff; font-weight: 500;"> <img src="https://www.svgrepo.com/show/306500/openai.svg" width="22" height="22" style="filter: invert(1);" alt="OpenAI Logo"/> Auto Sora <span style="font-size: 9px; opacity: 0.6; font-weight: 300; margin-left: -5px;">build 4.8</span> </h3> <button id="sora-close" style=" background: rgba(80, 80, 80, 0.4); backdrop-filter: blur(5px) saturate(150%); -webkit-backdrop-filter: blur(5px) saturate(150%); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 2px 6px; font-size: 16px; color: rgba(255, 255, 255, 0.7); cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; " onmouseover="this.style.backgroundColor='rgba(100, 100, 100, 0.6)'; this.style.color='rgba(255, 255, 255, 0.9)'; this.style.borderColor='rgba(255, 255, 255, 0.15)'" onmouseout="this.style.backgroundColor='rgba(80, 80, 80, 0.4)'; this.style.color='rgba(255, 255, 255, 0.7)'; this.style.borderColor='rgba(255, 255, 255, 0.1)'" title="ƒê√≥ng b·∫£ng ƒëi·ªÅu khi·ªÉn">‚úï</button> </div>
            <label style="font-size: 13px; color: #bdbdbd; font-weight: 400; margin-bottom: 5px; display: block;">Nh·∫≠p danh s√°ch prompt:</label> <textarea rows="5" id="sora-input" placeholder="M·ªói d√≤ng t∆∞∆°ng ·ª©ng v·ªõi m·ªôt prompt..." style="width: 100%; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(0, 0, 0, 0.25); border-radius: 10px; resize: vertical; font-size: 14px; color: #e0e0e0; margin-top: 0px; margin-bottom: 12px; box-sizing: border-box; min-height: 80px;"></textarea>
            <label style="display: block; font-size: 13px; color: #bdbdbd; font-weight: 400; margin-bottom: 5px;">‚è± Th·ªùi gian Cooldown (gi√¢y):</label> <input id="sora-cooldown-time" type="number" min="1" value="${cooldownTime}" style="width: 100%; padding: 8px 12px; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(0, 0, 0, 0.25); color: #e0e0e0; border-radius: 10px; font-size: 14px; margin-top: 0px; box-sizing: border-box; margin-bottom: 15px;" />
            <div style="display: flex; gap: 10px; margin-bottom: 20px;"> <button id="sora-start" style=" flex: 1; background: rgba(60, 130, 250, 0.5); backdrop-filter: blur(5px) saturate(150%); -webkit-backdrop-filter: blur(5px) saturate(150%); color: white; padding: 10px; border: 1px solid rgba(60, 130, 250, 0.6); border-radius: 10px; cursor: pointer; font-weight: 500; transition: background-color 0.2s ease, border-color 0.2s ease; " onmouseover="this.style.backgroundColor='rgba(60, 130, 250, 0.7)'; this.style.borderColor='rgba(60, 130, 250, 0.8)'" onmouseout="this.style.backgroundColor='rgba(60, 130, 250, 0.5)'; this.style.borderColor='rgba(60, 130, 250, 0.6)'">‚ñ∂ B·∫Øt ƒë·∫ßu</button> <button id="sora-clear" style=" flex: 1; background: rgba(80, 80, 80, 0.5); backdrop-filter: blur(5px) saturate(150%); -webkit-backdrop-filter: blur(5px) saturate(150%); color: #d0d0d0; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 10px; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; " onmouseover="this.style.backgroundColor='rgba(100, 100, 100, 0.6)'; this.style.borderColor='rgba(255, 255, 255, 0.2)'" onmouseout="this.style.backgroundColor='rgba(80, 80, 80, 0.5)'; this.style.borderColor='rgba(255, 255, 255, 0.15)'">üóëÔ∏è X√≥a</button> </div>
            <hr style="border: none; border-top: 1px solid rgba(255, 255, 255, 0.1); margin: 18px 0;" />
            <div style="font-size: 13px; color: #bdbdbd; margin-bottom: 12px; font-weight: 400;">Ch·ªçn ·∫£nh t·∫£i v·ªÅ:</div> <div style="display: flex; gap: 18px; margin-bottom: 15px; flex-wrap: wrap; justify-content: flex-start; align-items: center;"> <label title="Ch·ªâ ch·ªçn c√°c ·∫£nh c√≥ chi·ªÅu ngang l·ªõn h∆°n chi·ªÅu d·ªçc" style="display: flex; align-items: center; gap: 7px; font-size: 13px; color: #d0d0d0; cursor: pointer;"> <input type="checkbox" id="sora-select-horizontal" style="transform: scale(1.1); cursor: pointer; accent-color: #4a90e2;" /> ·∫¢nh ngang </label> <label title="Ch·ªâ ch·ªçn c√°c ·∫£nh c√≥ chi·ªÅu d·ªçc l·ªõn h∆°n chi·ªÅu ngang" style="display: flex; align-items: center; gap: 7px; font-size: 13px; color: #d0d0d0; cursor: pointer;"> <input type="checkbox" id="sora-select-vertical" style="transform: scale(1.1); cursor: pointer; accent-color: #4a90e2;" /> ·∫¢nh d·ªçc </label> <label title="Ch·ªâ ch·ªçn c√°c ·∫£nh c√≥ chi·ªÅu r·ªông b·∫±ng chi·ªÅu cao" style="display: flex; align-items: center; gap: 7px; font-size: 13px; color: #d0d0d0; cursor: pointer;"> <input type="checkbox" id="sora-select-square" style="transform: scale(1.1); cursor: pointer; accent-color: #4a90e2;" /> ·∫¢nh vu√¥ng </label> </div>
            <hr style="border: none; border-top: 1px solid rgba(255, 255, 255, 0.08); margin: 18px 0;" />
            <div style="font-size: 13px; color: #bdbdbd; margin-bottom: 10px; font-weight: 400;">T√πy ch·ªçn Crop ·∫£nh khi t·∫£i:</div> <div id="sora-crop-options" style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 15px; margin-bottom: 15px;"> <label style="display: flex; align-items: center; gap: 5px; font-size: 13px; color: #d0d0d0; cursor: pointer;"> <input type="radio" name="sora-crop-option" value="none" checked style="cursor: pointer; accent-color: #4a90e2; transform: scale(1.1);" /> G·ªëc </label> <label style="display: flex; align-items: center; gap: 5px; font-size: 13px; color: #d0d0d0; cursor: pointer;"> <input type="radio" name="sora-crop-option" value="16:9" style="cursor: pointer; accent-color: #4a90e2; transform: scale(1.1);" /> 16:9 </label> <label style="display: flex; align-items: center; gap: 5px; font-size: 13px; color: #d0d0d0; cursor: pointer;"> <input type="radio" name="sora-crop-option" value="9:16" style="cursor: pointer; accent-color: #4a90e2; transform: scale(1.1);" /> 9:16 </label> <label style="display: flex; align-items: center; gap: 5px; font-size: 13px; color: #d0d0d0; cursor: pointer;"> <input type="radio" name="sora-crop-option" value="1:1" style="cursor: pointer; accent-color: #4a90e2; transform: scale(1.1);" /> 1:1 </label> </div>
            <div style="display: flex; gap: 10px; margin-top: 20px; align-items: stretch;"> <button id="sora-download-images" style=" flex-grow: 1; background: rgba(46, 160, 67, 0.5); backdrop-filter: blur(5px) saturate(150%); -webkit-backdrop-filter: blur(5px) saturate(150%); color: white; padding: 11px; border: 1px solid rgba(46, 160, 67, 0.6); border-radius: 10px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; gap: 8px; transition: background-color 0.2s ease, border-color 0.2s ease, opacity 0.2s ease; font-weight: 500; " onmouseover="if(!this.disabled) { this.style.backgroundColor='rgba(46, 160, 67, 0.7)'; this.style.borderColor='rgba(46, 160, 67, 0.8)'; }" onmouseout="if(!this.disabled) { this.style.backgroundColor='rgba(46, 160, 67, 0.5)'; this.style.borderColor='rgba(46, 160, 67, 0.6)'; }"> <svg id="sora-download-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16" style="display: inline;"> <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/> <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/> </svg> <span id="sora-download-text">T·∫£i h√¨nh (0)</span> </button> <button id="sora-find-similar-button" title="K√≠ch ho·∫°t ch·∫ø ƒë·ªô t√¨m ·∫£nh t∆∞∆°ng t·ª±" style=" flex-shrink: 0; background: rgba(80, 80, 90, 0.5); backdrop-filter: blur(5px) saturate(150%); -webkit-backdrop-filter: blur(5px) saturate(150%); color: white; padding: 11px 14px; border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 10px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s ease, border-color 0.2s ease; " onmouseover="if(!this.classList.contains('active')) { this.style.backgroundColor='rgba(100, 100, 110, 0.6)'; this.style.borderColor='rgba(255, 255, 255, 0.2)'; }" onmouseout="if(!this.classList.contains('active')) { this.style.backgroundColor='rgba(80, 80, 90, 0.5)'; this.style.borderColor='rgba(255, 255, 255, 0.15)'; }"> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cursor-fill" viewBox="0 0 16 16"> <path d="M14.082 2.182a.5.5 0 0 1 .103.557L8.528 15.467a.5.5 0 0 1-.917-.007L5.57 10.694.803 8.652a.5.5 0 0 1-.006-.916l12.728-5.657a.5.5 0 0 1 .556.103z"/> </svg> </button> </div>
            <style> #sora-download-images:disabled { background: rgba(80, 80, 80, 0.3) !important; border-color: rgba(255, 255, 255, 0.08) !important; color: rgba(255, 255, 255, 0.4) !important; backdrop-filter: blur(2px) saturate(100%); -webkit-backdrop-filter: blur(2px) saturate(100%); opacity: 0.6; cursor: not-allowed; } #sora-find-similar-button.active { background-color: rgba(60, 130, 250, 0.65) !important; border-color: rgba(60, 130, 250, 0.8) !important; } </style>
            <div id="sora-download-progress" style="display: none;"></div>
            <div id="sora-download-error" style="font-size: 11px; color: #ff8a8a; text-align: center; margin-top: 5px; font-weight: 400;"></div>
        `;
        document.body.appendChild(wrapper);
        let isDragging = false; let offsetX, offsetY; function dragMouseDown(e) { if (e.button !== 0) return; const targetTagName = e.target.tagName.toLowerCase(); const isInteractive = ['input', 'button', 'textarea', 'svg', 'span'].includes(targetTagName) || e.target.closest('button, input, textarea, a, label[style*="cursor: pointer"]'); if (isInteractive) { return; } isDragging = true; wrapper.style.cursor = 'grabbing'; const rect = wrapper.getBoundingClientRect(); offsetX = e.clientX - rect.left; offsetY = e.clientY - rect.top; wrapper.style.bottom = 'auto'; wrapper.style.top = `${rect.top}px`; wrapper.style.left = `${rect.left}px`; document.addEventListener('mousemove', elementDrag); document.addEventListener('mouseup', closeDragElement); e.preventDefault(); } function elementDrag(e) { if (isDragging) { e.preventDefault(); const newTop = e.clientY - offsetY; const newLeft = e.clientX - offsetX; wrapper.style.top = `${newTop}px`; wrapper.style.left = `${newLeft}px`; } } function closeDragElement() { if (isDragging) { isDragging = false; wrapper.style.cursor = 'grab'; document.removeEventListener('mousemove', elementDrag); document.removeEventListener('mouseup', closeDragElement); } } wrapper.addEventListener('mousedown', dragMouseDown); wrapper.style.cursor = 'grab';
        document.getElementById('sora-start').onclick = handleStart; document.getElementById('sora-clear').onclick = handleClear; document.getElementById('sora-close').onclick = handleClose; document.getElementById('sora-download-images').onclick = handleDownload; document.getElementById('sora-find-similar-button').onclick = toggleFindSimilarMode;
        document.getElementById('sora-select-horizontal').addEventListener('change', updateImageSelection); document.getElementById('sora-select-vertical').addEventListener('change', updateImageSelection); document.getElementById('sora-select-square').addEventListener('change', updateImageSelection);
        createAuxiliaryUI();
    }

    function createAuxiliaryUI() { const auxContainer = document.createElement('div'); auxContainer.id = 'sora-aux-controls-container'; auxContainer.style.cssText = `position: fixed; bottom: 15px; left: 20px; z-index: 999998; display: none; align-items: center; gap: 10px; transition: opacity 0.3s ease; opacity: 1;`; const glassItemStyle = `background: rgba(45, 45, 50, 0.7); backdrop-filter: blur(8px) saturate(150%); -webkit-backdrop-filter: blur(8px) saturate(150%); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 10px; padding: 8px 14px; font-size: 13px; color: #d5d5d5; display: none; white-space: nowrap; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); transition: background-color 0.2s ease, border-color 0.2s ease;`; const progress = document.createElement('div'); progress.id = 'sora-progress'; progress.style.cssText = glassItemStyle; progress.textContent = 'ƒêang x·ª≠ l√Ω...'; auxContainer.appendChild(progress); const cooldownBtn = document.createElement('button'); cooldownBtn.id = 'sora-cooldown'; cooldownBtn.style.cssText = glassItemStyle + `cursor: default;`; cooldownBtn.textContent = `‚è≥ Cooldown: ${cooldownTime}s`; auxContainer.appendChild(cooldownBtn); const stopBtn = document.createElement('button'); stopBtn.id = 'sora-stop-button'; stopBtn.style.cssText = glassItemStyle + `background: rgba(200, 50, 60, 0.7); border-color: rgba(255, 99, 132, 0.4); color: white; cursor: pointer; font-weight: 500;`; stopBtn.textContent = 'üõë D·ª´ng'; stopBtn.title = 'D·ª´ng g·ª≠i prompt v√† l∆∞u c√°c prompt c√≤n l·∫°i'; stopBtn.onclick = handleStop; stopBtn.onmouseover = function() { this.style.backgroundColor='rgba(220, 53, 69, 0.8)'; this.style.borderColor='rgba(255, 99, 132, 0.6)'; }; stopBtn.onmouseout = function() { this.style.backgroundColor='rgba(200, 50, 60, 0.7)'; this.style.borderColor='rgba(255, 99, 132, 0.4)'; }; auxContainer.appendChild(stopBtn); document.body.appendChild(auxContainer); const miniBtn = document.createElement('div'); miniBtn.id = 'sora-minibtn'; miniBtn.style.cssText = `position: fixed; bottom: 15px; left: 20px; width: 16px; height: 16px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; cursor: pointer; z-index: 999999; box-shadow: 0 0 8px rgba(255, 255, 255, 0.5); display: none; border: 1px solid rgba(255, 255, 255, 0.3); transition: background-color 0.2s ease;`; miniBtn.onmouseover = function() { this.style.backgroundColor='rgba(255, 255, 255, 1)'; }; miniBtn.onmouseout = function() { this.style.backgroundColor='rgba(255, 255, 255, 0.8)'; }; miniBtn.title = 'M·ªü l·∫°i Auto Sora'; miniBtn.onclick = handleMiniButtonClick; document.body.appendChild(miniBtn); }

    function handleStart() { const input = document.getElementById('sora-input').value; const prompts = input.split('\n').map(x => x.trim()).filter(Boolean); const cooldownInput = parseInt(document.getElementById('sora-cooldown-time').value); cooldownTime = isNaN(cooldownInput) ? 130 : Math.max(1, cooldownInput); if (prompts.length === 0) return alert("‚ùó Nh·∫≠p √≠t nh·∫•t 1 prompt."); if (isRunning) { log("Process already running."); return; } log(`Starting process with ${prompts.length} prompts and ${cooldownTime}s cooldown.`); promptQueue = prompts; totalPromptCount = prompts.length; isRunning = true; const mainUI = document.getElementById('sora-auto-ui'); if (mainUI) { mainUI.style.opacity = '0'; mainUI.style.transform = 'scale(0.95)'; setTimeout(() => { mainUI.style.display = 'none'; }, 300); } document.getElementById('sora-minibtn').style.display = 'none'; const auxContainer = document.getElementById('sora-aux-controls-container'); const progressEl = document.getElementById('sora-progress'); const cooldownEl = document.getElementById('sora-cooldown'); const stopBtn = document.getElementById('sora-stop-button'); if(auxContainer) auxContainer.style.display = 'flex'; if(progressEl) progressEl.style.display = 'inline-block'; if(cooldownEl) cooldownEl.style.display = 'inline-block'; if(stopBtn) stopBtn.style.display = 'inline-block'; updateProgress(); startLoop(); }
    function handleClear() { document.getElementById('sora-input').value = ''; log("Prompt input cleared."); }
    function handleClose() { const wrapper = document.getElementById('sora-auto-ui'); if (!wrapper) return; wrapper.style.opacity = '0'; wrapper.style.transform = 'scale(0.95)'; setTimeout(() => { wrapper.style.display = 'none'; if (!isRunning) { const miniBtn = document.getElementById('sora-minibtn'); if (miniBtn) miniBtn.style.display = 'block'; } }, 300); }
    function handleMiniButtonClick() { if (!isRunning) { const wrapper = document.getElementById('sora-auto-ui'); const miniBtn = document.getElementById('sora-minibtn'); if (wrapper) { wrapper.style.display = 'block'; void wrapper.offsetWidth; wrapper.style.opacity = '1'; wrapper.style.transform = 'scale(1)'; } if (miniBtn) miniBtn.style.display = 'none'; const auxContainer = document.getElementById('sora-aux-controls-container'); if (auxContainer) auxContainer.style.display = 'none'; } else { log("Cannot open UI while process is running."); } }

    function handleStop() { log("Stop button clicked."); if (!isRunning) { log("Process is not running."); return; } isRunning = false; const done = totalPromptCount - promptQueue.length; const progressEl = document.getElementById('sora-progress'); if(progressEl) { progressEl.textContent = `ƒê√£ d·ª´ng: ${done} / ${totalPromptCount}`; log(`Process stopped manually after ${done} prompts.`); } if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; const cooldownBtn = document.getElementById('sora-cooldown'); if (cooldownBtn) cooldownBtn.textContent = 'Cooldown: --'; log("Cooldown timer cleared."); } if (promptQueue.length > 0) { saveRemainingPromptsToFile(); } else { log("No remaining prompts to save."); } setTimeout(() => { if (!isRunning) { const auxContainer = document.getElementById('sora-aux-controls-container'); if (auxContainer) auxContainer.style.display = 'none'; const miniBtn = document.getElementById('sora-minibtn'); if (miniBtn) miniBtn.style.display = 'block'; totalPromptCount = 0; } }, 4000); }
    function saveRemainingPromptsToFile() { if (!promptQueue || promptQueue.length === 0) { log("Attempted to save prompts, but queue is empty."); return; } log(`Saving ${promptQueue.length} remaining prompts to file...`); const content = promptQueue.join('\n'); const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); const filename = `AutoSora_remaining_${getTimestamp()}.txt`; try { triggerDownload(blob, filename); log("Remaining prompts file download triggered."); } catch (e) { log("Error triggering download for remaining prompts file:"); console.error(e); } }

    function updateProgress() { const progressEl = document.getElementById('sora-progress'); const auxContainer = document.getElementById('sora-aux-controls-container'); const cooldownEl = document.getElementById('sora-cooldown'); const stopBtn = document.getElementById('sora-stop-button'); if (!progressEl || !auxContainer) return; const done = totalPromptCount - promptQueue.length; if (isRunning) { progressEl.textContent = `ƒê√£ g·ª≠i: ${done} / ${totalPromptCount}`; auxContainer.style.display = 'flex'; progressEl.style.display = 'inline-block'; if(cooldownEl) cooldownEl.style.display = 'inline-block'; if(stopBtn) stopBtn.style.display = 'inline-block'; } else { if (totalPromptCount > 0 && done === totalPromptCount) { progressEl.textContent = `Ho√†n th√†nh: ${done} / ${totalPromptCount}.`; log(`Finished processing all ${totalPromptCount} prompts.`); } else if (totalPromptCount > 0 && progressEl.textContent.indexOf('ƒê√£ d·ª´ng') === -1) { progressEl.textContent = `ƒê√£ d·ª´ng: ${done} / ${totalPromptCount}.`; log(`Process stopped or finished incompletely after ${done} prompts (updateProgress check).`); } else if (totalPromptCount === 0 && progressEl.textContent.indexOf('ƒê√£ d·ª´ng') === -1) { progressEl.textContent = 'Ch∆∞a ch·∫°y/ƒê√£ d·ª´ng.'; } setTimeout(() => { if (!isRunning) { if (auxContainer) auxContainer.style.display = 'none'; const wrapper = document.getElementById('sora-auto-ui'); const miniBtn = document.getElementById('sora-minibtn'); if (wrapper && wrapper.style.display === 'none' && miniBtn) { miniBtn.style.display = 'block'; } if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; } if (totalPromptCount > 0 && done === totalPromptCount) { totalPromptCount = 0; } } }, 4000); } }
    function startCountdown() { let timeRemaining = cooldownTime; const cooldownBtn = document.getElementById('sora-cooldown'); if (!cooldownBtn || !isRunning) return; cooldownBtn.textContent = `‚è≥ ${timeRemaining}s`; if (countdownInterval) clearInterval(countdownInterval); countdownInterval = setInterval(() => { if (!isRunning) { clearInterval(countdownInterval); countdownInterval = null; const currentBtn = document.getElementById('sora-cooldown'); if(currentBtn) currentBtn.textContent = `‚è≥ --`; log("Countdown stopped because isRunning is false."); return; } timeRemaining--; const currentBtn = document.getElementById('sora-cooldown'); if (currentBtn) currentBtn.textContent = `‚è≥ ${timeRemaining}s`; if (timeRemaining <= 0) { clearInterval(countdownInterval); countdownInterval = null; if (currentBtn) currentBtn.textContent = `‚è≥ 0s`; } }, 1000); }

    function submitPrompt(prompt) { if (!isRunning) { log("submitPrompt cancelled because isRunning is false."); return; } const textarea = document.querySelector('textarea[placeholder*="Describe your"]'); if (!textarea) { log("Error: Prompt textarea not found. Stopping process."); handleStop(); return; } log(`Submitting prompt: ${prompt.substring(0, 50)}...`); textarea.value = prompt; const key = Object.keys(textarea).find(k => k.startsWith("__reactProps$")); if (key && textarea[key]?.onChange) { try { log("Triggering React onChange..."); textarea[key].onChange({ target: textarea }); } catch (e) { log("Error triggering React onChange:"); console.error(e); } } else { log("Warning: React onChange handler not found. Attempting standard events."); textarea.dispatchEvent(new Event('input', { bubbles: true })); textarea.dispatchEvent(new Event('change', { bubbles: true })); } setTimeout(() => { if (!isRunning) { log("Submit button click cancelled because isRunning is false."); return; } const btn = document.querySelector('button[data-disabled="false"]'); if (btn) { log("Submit button found, attempting React onClick..."); const btnKey = Object.keys(btn).find(k => k.startsWith("__reactProps$")); if (btnKey && btn[btnKey]?.onClick) { try { btn[btnKey].onClick({ bubbles: true, cancelable: true, isTrusted: true }); log("React onClick triggered."); } catch (e) { log("Error triggering React onClick:"); console.error(e); log("Attempting standard .click() as fallback..."); btn.click(); } } else { log("Warning: React onClick handler not found on button. Attempting standard .click()."); btn.click(); } } else { log("Error: Submit button (data-disabled='false') not found after delay."); } }, 600); }

    function processNextPrompt() { if (!isRunning || promptQueue.length === 0) { if (isRunning && promptQueue.length === 0) { log("Queue empty. Ending loop naturally."); isRunning = false; } else if (!isRunning) { log("processNextPrompt: Loop stopping because isRunning is false."); } updateProgress(); return; } const currentCooldownInput = parseInt(document.getElementById('sora-cooldown-time')?.value ?? cooldownTime.toString()); const currentCooldown = isNaN(currentCooldownInput) ? cooldownTime : Math.max(1, currentCooldownInput); log(`Waiting ${currentCooldown} seconds for next prompt...`); startCountdown(); setTimeout(() => { if (!isRunning) { log("Process stopped during cooldown wait."); return; } if (promptQueue.length > 0) { const nextPrompt = promptQueue.shift(); log(`Processing next prompt (${totalPromptCount - promptQueue.length}/${totalPromptCount})`); submitPrompt(nextPrompt); updateProgress(); if (promptQueue.length > 0) { processNextPrompt(); } else { log("Last prompt submitted, queue is now empty."); isRunning = false; updateProgress(); } } else { log("Queue became empty unexpectedly during cooldown."); isRunning = false; updateProgress(); } }, currentCooldown * 1000); }
    function startLoop() { if (!isRunning || promptQueue.length === 0) { log("Loop not started or queue empty."); isRunning = false; updateProgress(); return; } const firstPrompt = promptQueue.shift(); log(`Starting loop, submitting first prompt (1/${totalPromptCount}): ${firstPrompt.substring(0, 50)}...`); submitPrompt(firstPrompt); updateProgress(); if (promptQueue.length > 0) { processNextPrompt(); } else { log("Only one prompt was in the queue. Loop finished."); isRunning = false; updateProgress(); } }

    // --- Download Logic ---
    function updateSelectedCount() { const count = selectedImageUrls.size; try { const btnText = document.getElementById("sora-download-text"); const btn = document.getElementById("sora-download-images"); const icon = document.getElementById("sora-download-icon"); const errorEl = document.getElementById("sora-download-error"); if (btnText && btn && !isDownloading) { btnText.textContent = `T·∫£i h√¨nh (${count})`; btn.disabled = (count === 0); if (icon) icon.style.display = 'inline'; if (errorEl) errorEl.textContent = ''; } else if (btn) { btn.disabled = true; } } catch (e) { log("Error updating selected count UI:"); console.error(e); } const btn = document.getElementById("sora-download-images"); if (btn && !isDownloading) { btn.disabled = (selectedImageUrls.size === 0); } }
    async function handleDownload() { const btn = document.getElementById("sora-download-images"); const btnText = document.getElementById("sora-download-text"); const btnIcon = document.getElementById("sora-download-icon"); const errorEl = document.getElementById("sora-download-error"); if (!btn || !btnText || !btnIcon || !errorEl) { log("Error: Download UI elements not found."); return; } if (isDownloading) { log("Download stop requested."); isDownloading = false; btnText.textContent = `ƒêang d·ª´ng...`; return; } const urlsToDownload = Array.from(selectedImageUrls); if (urlsToDownload.length === 0) { errorEl.textContent = "Ch∆∞a c√≥ ·∫£nh n√†o ƒë∆∞·ª£c ch·ªçn."; setTimeout(() => { if (!isDownloading && errorEl) errorEl.textContent = ''; }, 3000); return; } isDownloading = true; downloadErrors = 0; let successfulCount = 0; const totalFiles = urlsToDownload.length; const selectedCropOption = document.querySelector('input[name="sora-crop-option"]:checked')?.value ?? 'none'; btn.disabled = true; btnIcon.style.display = 'none'; btnText.textContent = `Chu·∫©n b·ªã... (0/${totalFiles})`; errorEl.textContent = ''; log(`Starting download of ${totalFiles} images... Crop: ${selectedCropOption}`); if (totalFiles === 1) { log("Processing single image download..."); const url = urlsToDownload[0]; btnText.textContent = `ƒêang x·ª≠ l√Ω 1 ·∫£nh...`; try { const blob = await convertWebpToPngBlob(url, selectedCropOption); if (blob && isDownloading) { const timestamp = getTimestamp(); const filename = `AutoSora_${selectedCropOption}_${timestamp}.png`; triggerDownload(blob, filename); btnText.textContent = `ƒê√£ t·∫£i xong 1 ·∫£nh`; successfulCount = 1; } else if (!blob && isDownloading) { downloadErrors = 1; errorEl.textContent = `L·ªói x·ª≠ l√Ω ·∫£nh. Ki·ªÉm tra Console.`; btnText.textContent = `L·ªói t·∫£i ·∫£nh`; } else if (!isDownloading) { errorEl.textContent = `ƒê√£ d·ª´ng t·∫£i.`; btnText.textContent = `ƒê√£ d·ª´ng t·∫£i`; } } catch (err) { if (isDownloading) { downloadErrors = 1; log(`Error processing single image (${url.substring(0, 30)}...): ${err.message}`); console.error(err); errorEl.textContent = `L·ªói x·ª≠ l√Ω ·∫£nh. Ki·ªÉm tra Console.`; btnText.textContent = `L·ªói t·∫£i ·∫£nh`; } else { errorEl.textContent = `ƒê√£ d·ª´ng t·∫£i.`; btnText.textContent = `ƒê√£ d·ª´ng t·∫£i`; } } finally { const wasDownloading = isDownloading; isDownloading = false; if (btnIcon) btnIcon.style.display = 'inline'; setTimeout(() => { if (!isDownloading) updateSelectedCount(); }, 5000); log(`Single image download process finished (was downloading: ${wasDownloading}).`); } return; } log("Processing multiple images concurrently..."); let processedImageCount = 0; btnText.textContent = `ƒêang x·ª≠ l√Ω ·∫£nh: 0/${totalFiles} (0%)`; const conversionPromises = urlsToDownload.map((url, index) => { return convertWebpToPngBlob(url, selectedCropOption) .then(blob => { if (isDownloading) { processedImageCount++; const percentage = ((processedImageCount / totalFiles) * 100).toFixed(0); btnText.textContent = `ƒêang x·ª≠ l√Ω ·∫£nh: ${processedImageCount}/${totalFiles} (${percentage}%)`; log(`Processed image ${processedImageCount}/${totalFiles} (Success)`); } return blob; }) .catch(error => { if (isDownloading) { processedImageCount++; const percentage = ((processedImageCount / totalFiles) * 100).toFixed(0); btnText.textContent = `ƒêang x·ª≠ l√Ω ·∫£nh: ${processedImageCount}/${totalFiles} (${percentage}%)`; log(`Processed image ${processedImageCount}/${totalFiles} (Failed: ${error.message})`); } throw error; }); }); const results = await Promise.allSettled(conversionPromises); if (!isDownloading) { log("Download stopped during image processing phase."); errorEl.textContent = "ƒê√£ d·ª´ng t·∫£i."; btnText.textContent = "ƒê√£ d·ª´ng t·∫£i"; if(btnIcon) btnIcon.style.display = 'inline'; setTimeout(() => { if (!isDownloading) updateSelectedCount(); }, 5000); return; } log("All image processing settled. Preparing ZIP..."); btnText.textContent = `ƒê√£ x·ª≠ l√Ω ${totalFiles}/${totalFiles} (100%). Chu·∫©n b·ªã ZIP...`; const zip = new JSZip(); let zipFileCount = 0; results.forEach((result, index) => { if (!isDownloading) return; if (result.status === 'fulfilled' && result.value) { const blob = result.value; const filename = `image_${index + 1}.png`; zip.file(filename, blob); successfulCount++; zipFileCount++; log(`Added ${filename} to zip.`); } else { downloadErrors++; const reason = result.status === 'rejected' ? result.reason : 'Unknown processing error'; log(`Error processing image index ${index} for ZIP: ${reason instanceof Error ? reason.message : reason}`); } }); if (!isDownloading) { log("Download stopped during ZIP preparation."); errorEl.textContent = "ƒê√£ d·ª´ng t·∫°o ZIP."; btnText.textContent = "ƒê√£ d·ª´ng t·∫°o ZIP"; if(btnIcon) btnIcon.style.display = 'inline'; setTimeout(() => { if (!isDownloading) updateSelectedCount(); }, 5000); return; } if (successfulCount > 0) { try { log("Generating ZIP file..."); btnText.textContent = 'ƒêang t·∫°o file ZIP...'; const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } }, (metadata) => { if (!isDownloading) throw new Error("Zip generation cancelled."); btnText.textContent = `ƒêang n√©n ZIP: ${metadata.percent.toFixed(0)}%`; }); if (!isDownloading) { log("Download stopped during ZIP generation."); errorEl.textContent = "ƒê√£ d·ª´ng t·∫°o ZIP."; btnText.textContent = "ƒê√£ d·ª´ng t·∫°o ZIP"; } else { const zipFilename = `AutoSora_Bulk_${getTimestamp()}.zip`; triggerDownload(zipBlob, zipFilename); btnText.textContent = `ƒê√£ t·∫£i xong ${successfulCount}/${totalFiles} ·∫£nh`; if (downloadErrors > 0) { errorEl.textContent = `C√≥ ${downloadErrors} l·ªói x·∫£y ra khi x·ª≠ l√Ω ·∫£nh.`; } log(`ZIP download triggered for ${successfulCount} files.`); } } catch (error) { log("Error during ZIP generation or download:"); console.error(error); if (error.message === "Zip generation cancelled.") { errorEl.textContent = "ƒê√£ d·ª´ng t·∫°o file ZIP."; btnText.textContent = "ƒê√£ d·ª´ng t·∫°o ZIP"; } else if (isDownloading){ errorEl.textContent = "L·ªói khi t·∫°o file ZIP. Ki·ªÉm tra Console."; btnText.textContent = "L·ªói t·∫°o ZIP"; } else { errorEl.textContent = "ƒê√£ d·ª´ng."; btnText.textContent = "ƒê√£ d·ª´ng"; } } } else if (isDownloading) { btnText.textContent = "L·ªói x·ª≠ l√Ω ·∫£nh"; errorEl.textContent = `Kh√¥ng th·ªÉ x·ª≠ l√Ω ·∫£nh n√†o (${downloadErrors} l·ªói).`; log("No images were successfully processed."); } else { log("Download stopped, no successful images to ZIP."); } const wasDownloadingMulti = isDownloading; isDownloading = false; if (btnIcon) btnIcon.style.display = 'inline'; setTimeout(() => { if (!isDownloading) updateSelectedCount(); }, 5000); log(`Multiple image download process finished (was downloading: ${wasDownloadingMulti}).`); }
    async function convertWebpToPngBlob(url, cropOption = 'none') { try { if (!isDownloading) throw new Error("Download cancelled before fetching."); const response = await fetch(url); if (!response.ok) throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`); const webpBlob = await response.blob(); if (webpBlob.size === 0) throw new Error("Fetched blob is empty."); if (!isDownloading) throw new Error("Download cancelled after fetching."); const imgBitmap = await createImageBitmap(webpBlob); let sourceX = 0, sourceY = 0; let sourceWidth = imgBitmap.width; let sourceHeight = imgBitmap.height; let targetWidth = imgBitmap.width; let targetHeight = imgBitmap.height; const targetCanvas = document.createElement("canvas"); if (cropOption !== 'none' && sourceWidth > 0 && sourceHeight > 0) { let targetRatio = 1; let canvasTargetWidth = sourceWidth; let canvasTargetHeight = sourceHeight; log(`Applying crop: ${cropOption} to ${sourceWidth}x${sourceHeight}`); switch (cropOption) { case '16:9': targetRatio = 16 / 9; canvasTargetWidth = 1920; canvasTargetHeight = 1080; break; case '9:16': targetRatio = 9 / 16; canvasTargetWidth = 1080; canvasTargetHeight = 1920; break; case '1:1': targetRatio = 1 / 1; canvasTargetWidth = 1080; canvasTargetHeight = 1080; break; } const currentRatio = sourceWidth / sourceHeight; if (Math.abs(currentRatio - targetRatio) < 0.01) { log(`Image already ~${cropOption}, resizing to target.`); } else if (currentRatio > targetRatio) { const idealWidth = sourceHeight * targetRatio; sourceX = (sourceWidth - idealWidth) / 2; sourceWidth = idealWidth; log(`Cropping width: sx=${sourceX.toFixed(0)}, sw=${sourceWidth.toFixed(0)}`); } else { const idealHeight = sourceWidth / targetRatio; sourceY = (sourceHeight - idealHeight) / 2; sourceHeight = idealHeight; log(`Cropping height: sy=${sourceY.toFixed(0)}, sh=${sourceHeight.toFixed(0)}`); } targetWidth = canvasTargetWidth; targetHeight = canvasTargetHeight; log(`Target canvas size set to ${targetWidth}x${targetHeight}`); } else { targetWidth = sourceWidth; targetHeight = sourceHeight; if (cropOption === 'none') log(`No crop applied. Target size: ${targetWidth}x${targetHeight}`); else log(`Crop skipped due to invalid source dimensions. Target size: ${targetWidth}x${targetHeight}`); } if (targetWidth <= 0 || targetHeight <= 0 || sourceWidth <= 0 || sourceHeight <= 0 || sourceX < 0 || sourceY < 0) { throw new Error(`Invalid dimensions calculated: Target ${targetWidth}x${targetHeight}, Source Rect ${sourceWidth.toFixed(0)}x${sourceHeight.toFixed(0)} at (${sourceX.toFixed(0)},${sourceY.toFixed(0)}) from ${imgBitmap.width}x${imgBitmap.height}`); } targetCanvas.width = targetWidth; targetCanvas.height = targetHeight; const ctx = targetCanvas.getContext("2d", { alpha: false }); ctx.imageSmoothingQuality = "high"; ctx.drawImage(imgBitmap, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight); return new Promise((resolve, reject) => { if (!isDownloading) return reject(new Error("Download cancelled before blob creation.")); targetCanvas.toBlob(blob => { if (blob) { if (!isDownloading) return reject(new Error("Download cancelled during blob creation.")); log(`Converted ${url.substring(0,30)}... to PNG blob (${(blob.size / 1024).toFixed(1)} KB)`); resolve(blob); } else { reject(new Error("Canvas toBlob returned null.")); } }, "image/png", 0.95); }); } catch (error) { if (error.message.includes("cancelled")) log(`Conversion cancelled for ${url.substring(0,30)}...: ${error.message}`); else { log(`Error converting image ${url.substring(0,30)}...: ${error.message}`); console.error(`Full error for ${url}:`, error); } throw error; } }

    // --- Checkbox Insertion and Image Observation ---
    function insertCheckbox(img) { try { const a = img.closest('a'); if (!a || a.parentElement?.classList?.contains("sora-image-wrapper")) return; const wrapper = document.createElement("div"); wrapper.className = "sora-image-wrapper"; wrapper.style.position = "relative"; wrapper.style.display = "inline-block"; wrapper.style.margin = "5px"; wrapper.style.verticalAlign = "top"; wrapper.style.lineHeight = "0"; const checkbox = document.createElement("input"); checkbox.type = "checkbox"; checkbox.className = "sora-image-checkbox"; Object.assign(checkbox.style, { position: "absolute", top: "8px", left: "8px", zIndex: "10", width: "18px", height: "18px", cursor: "pointer", transform: "scale(1.3)", accentColor: "#4a90e2" }); checkbox.title = "Ch·ªçn/b·ªè ch·ªçn ·∫£nh n√†y"; const setInitialCheckboxState = () => { try { if (!img.complete || img.naturalWidth === 0 || img.naturalHeight === 0) return; const filterHorizState = document.getElementById('sora-select-horizontal')?.checked ?? false; const filterVertState = document.getElementById('sora-select-vertical')?.checked ?? false; const filterSquareState = document.getElementById('sora-select-square')?.checked ?? false; const imgWidth = img.naturalWidth; const imgHeight = img.naturalHeight; let shouldBeChecked = false; const isHoriz = imgWidth > imgHeight; const isVert = imgHeight > imgWidth; const isSquare = imgWidth === imgHeight; if (!filterHorizState && !filterVertState && !filterSquareState) { shouldBeChecked = false; } else { shouldBeChecked = (filterHorizState && isHoriz) || (filterVertState && isVert) || (filterSquareState && isSquare); } if (checkbox.checked !== shouldBeChecked) { checkbox.checked = shouldBeChecked; } if (shouldBeChecked) { if (!selectedImageUrls.has(img.src)) { selectedImageUrls.add(img.src); updateSelectedCount(); } } else { if (selectedImageUrls.has(img.src)) { selectedImageUrls.delete(img.src); updateSelectedCount(); } } } catch (e) { log(`Error in setInitialCheckboxState for image: ${img.src.substring(0,50)}...`); console.error(e); } }; checkbox.addEventListener("change", (e) => { if (e.target.checked) selectedImageUrls.add(img.src); else selectedImageUrls.delete(img.src); updateSelectedCount(); }); const parent = a.parentElement; if (parent) { parent.insertBefore(wrapper, a); wrapper.appendChild(checkbox); wrapper.appendChild(a); } else { log(`Could not find parent for image link: ${a.href}`); return; } if (img.complete && img.naturalWidth > 0) { setInitialCheckboxState(); } else { img.addEventListener('load', setInitialCheckboxState); img.addEventListener('error', () => log(`Failed to load image for checkbox init: ${img.src.substring(0, 50)}...`)); } } catch (e) { log(`Error inserting checkbox for image: ${img?.src?.substring(0,50)}...`); console.error(e); } }
    const observer = new MutationObserver((mutations) => { let imagesToCheck = []; for (const mutation of mutations) { if (mutation.type === 'childList') { for (const node of mutation.addedNodes) { if (node.nodeType === 1) { if (node.tagName === 'IMG' && node.parentElement?.tagName === 'A' && !node.closest('.sora-image-wrapper')) { imagesToCheck.push(node); } else if (node.querySelectorAll) { node.querySelectorAll('a > img').forEach(img => { if (!img.closest('.sora-image-wrapper')) imagesToCheck.push(img); }); } } } } } if (imagesToCheck.length > 0) { log(`MutationObserver found ${imagesToCheck.length} new image(s).`); imagesToCheck.forEach(img => insertCheckbox(img)); } });


    // --- Find Similar Image Mode Functions ---
    function toggleFindSimilarMode() { isFindSimilarModeActive = !isFindSimilarModeActive; const button = document.getElementById('sora-find-similar-button'); if (button) { if (isFindSimilarModeActive) { button.classList.add('active'); button.title = 'T·∫Øt ch·∫ø ƒë·ªô t√¨m ·∫£nh t∆∞∆°ng t·ª± (Click v√†o ·∫£nh ƒë·ªÉ t√¨m)'; log("Find Similar mode ACTIVATED."); } else { button.classList.remove('active'); button.title = 'K√≠ch ho·∫°t ch·∫ø ƒë·ªô t√¨m ·∫£nh t∆∞∆°ng t·ª±'; log("Find Similar mode DEACTIVATED."); } } }
    // Uses GM_openInTab
    function handleDocumentClickForSimilar(event) {
        if (!isFindSimilarModeActive) { return; }
        const link = event.target.closest('a');
        if (!link || !link.href) { return; }
        const soraGenRegex = /^https?:\/\/sora\.com\/g\/(gen_[a-zA-Z0-9]+)/;
        const match = link.href.match(soraGenRegex);
        if (match && match[1]) {
            const genId = match[1];
            const exploreUrl = `https://sora.com/explore?query=${genId}`;
            log(`Find Similar Mode: Match found (${genId}). Opening in background: ${exploreUrl}`);
            event.preventDefault(); event.stopPropagation();
            // Use GM_openInTab to open in background
            if (typeof GM_openInTab === 'function') {
                try {
                    GM_openInTab(exploreUrl, { active: false, setParent: true });
                } catch (e) {
                     log("Error calling GM_openInTab. Falling back to window.open. Check browser console and Tampermonkey permissions.");
                     console.error("GM_openInTab error:", e);
                     window.open(exploreUrl, '_blank'); // Fallback
                }
            } else {
                log("Warning: GM_openInTab not available. Falling back to window.open.");
                window.open(exploreUrl, '_blank');
            }
        }
    }

    // --- Initialization ---
    function waitForElement(selector, callback) { log(`Waiting for element: ${selector}`); let checkCount = 0; const maxChecks = 40; const interval = setInterval(() => { checkCount++; const el = document.querySelector(selector); if (el) { clearInterval(interval); log(`Element found: ${selector}. Initializing...`); try { callback(el); log("Initialization callback executed."); } catch (e) { log("ERROR during initialization callback execution:"); console.error(e); alert("L·ªói nghi√™m tr·ªçng khi kh·ªüi ch·∫°y Auto Sora script. Kh√¥ng th·ªÉ t·∫°o UI. Ki·ªÉm tra Console (F12) ƒë·ªÉ bi·∫øt chi ti·∫øt."); } } else if (checkCount >= maxChecks) { clearInterval(interval); log(`Element ${selector} not found after ${maxChecks * 0.5} seconds. Script cannot initialize UI.`); alert(`Auto Sora: Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ quan tr·ªçng "${selector}" ƒë·ªÉ kh·ªüi ch·∫°y UI. Script c√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông.`); } }, 500); }

    // --- Script Entry Point ---
    if (typeof JSZip === 'undefined') { log("FATAL ERROR: JSZip library not loaded."); alert("L·ªói nghi√™m tr·ªçng: Th∆∞ vi·ªán JSZip ch∆∞a ƒë∆∞·ª£c t·∫£i."); return; } else { log("JSZip library loaded successfully."); }
    if (typeof GM_openInTab === 'undefined') { log("Warning: GM_openInTab is not defined. Make sure the script has the necessary @grant permission in Tampermonkey/Greasemonkey. Background tabs might not work reliably."); }

    waitForElement('textarea[placeholder*="Describe your"]', () => {
        try {
            createUI(); log("UI Created.");
            log("Performing initial scan for images..."); document.querySelectorAll("a > img").forEach(img => { if (!img.closest('.sora-image-wrapper')) insertCheckbox(img); }); log("Initial image scan complete."); updateSelectedCount();
            log("Starting MutationObserver..."); observer.observe(document.body, { childList: true, subtree: true }); log("MutationObserver started.");
            document.addEventListener('click', handleDocumentClickForSimilar, true); log("Added global click listener for Find Similar mode.");
        } catch (e) { log("ERROR during script initialization after element found:"); console.error(e); alert("ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh kh·ªüi t·∫°o Auto Sora sau khi t√¨m th·∫•y ph·∫ßn t·ª≠. Ki·ªÉm tra Console (F12)."); }
    });

})();
